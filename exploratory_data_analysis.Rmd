---
title: "Intersecting soil point observations with environmental covariates"
author: "OchiengHosea"
date: "10/12/2020"
output: html_document
---
```{r}
library(ithir)
data(HV_subsoilpH)
str(HV_subsoilpH)
```
As you will note, there are 506 observations of soil pH. These data are associated with a spatial coordinate and also have associated environmental covariate data that have been intersected with the point data. The environmental covariates have been sourced from a digital elevation model and Landsat 7 satellite data. For the demonstration purposes of the exercise, we will firstly remove this already intersected data and start fresh - essentially this is an opportunity to recall earlier work on dataframe manipulation and indexing.
```{r}
# round pH data to 2 decimal places
HV_subsoilpH$pH60_100cm <- round(HV_subsoilpH$pH60_100cm, 2)

# remove already intersected data
HV_subsoilpH <- HV_subsoilpH[, 1:3]

# add an id column
HV_subsoilpH$id <- seq(1, nrow(HV_subsoilpH), by = 1)

# re-arrange order of columns
HV_subsoilpH <- HV_subsoilpH[, c(4, 1, 2, 3)]

# Change names of coordinate columns
names(HV_subsoilpH)[2:3] <- c("x", "y")
```

Also in the ithir package are a collection of rasters that correspond to environmental covariates that cover the extent of the just loaded soil point data. These can be loaded using the script:

```{r}
data(hunterCovariates_sub)
hunterCovariates_sub
```
While the example is a little contrived, it is useful to always determine whether or not the available covariates have complete coverage of the soil point data. This might be done with the following script which will produce a map like in the figure below.

```{r}
plot(hunterCovariates_sub[["Elevation"]], main = "Hunter Valley elevation map with overlayed point locations")
# coordinates(HV_subsoilpH) <- ~x + y
plot(HV_subsoilpH, add=T)
```
With the soil point data and covariates prepared, it is time to perform the intersection between the soil observations and covariate layers using the script:

```{r}
# coordinates(HV_subsoilpH) <- ~x + y
DSM_data <- extract(x=hunterCovariates_sub, y=HV_subsoilpH, sp=1, method = "simple")
```
The extract function is quite useful. Essentially the function ingests the rasterStack object, together with the SpatialPointsDataFrame object HV_subsoilpH. The sp parameter set to 1 means that the extracted covariate data gets appended to the existing SpatialPointsDataFrame object. While the method object specifies the extraction method which in our case is simple which likened to get the covariate value nearest to the points i.e it is likened to drilling down.

A good practice is to then export the soil and covariate data intersect object to file for later use. First we convert the spatial object to a data.frame, then export as a comma separated file.

```{r}

DSM_data <- as.data.frame(DSM_data)
write.csv(DSM_data, "hunterValley_SoilCovariates_pH.csv", row.names = FALSE)
```
# Some exploratory data analysis

```{r}
library(sp)
library(raster)
library(gstat)
library(nortest)
library(fBasics)
library(ggplot2)
```

# Some summary statistics
```{r}
hv.dat <- read.csv("hunterValley_SoilCovariates_pH.csv")
str(hv.dat)
```
```{r}
round(summary(hv.dat$pH60_100cm), 1)
```
since mean and median are close, we can assume that the data does not deviate too much from the normal
```{r}
sampleSKEW(hv.dat$pH60_100cm)
sampleKURT(hv.dat$pH60_100cm)
ad.test(hv.dat$pH60_100cm)
par(mfrow = c(1,2))
hist(hv.dat$pH60_100cm)
qqnorm(hv.dat$pH60_100cm, plot.it = TRUE, pch = 4, cex = 0.7)
qqline(hv.dat$pH60_100cm, col = "red", lwd = 2)
```
Another useful exploratory test is to visualize the data in its spatial context. Mapping the point locations with respect to the target variable by either altering the size or color of the marker gives a quick way to examine the target soil attribute spatial variability. Using the ggplot2 package, we could create the plot as shown below.

```{r}
ggplot(hv.dat, aes(x = x, y = y)) + geom_point(aes(size = hv.dat$pH60_100cm))
```
Spatial distribution of points in the Hunter Valley for the soil pH data at the 60-100cm depth interval. Size of the markings is relative to the pH measurement reading.


# Inverse Distance weighted interpolation
Functions for IDW interpolation and krigging are found in the gstat package

To initiate these interpolation methods, we first need to prepare a grid of points upon which the interpolation will be made

This can be done by either extracting the cordinates from either of the 25m resolution rasters we have for the hunter valley.

To extract pixel the pixel point coordinates from raster, we do the following using the `hunterCovariates_sub` raster stack

```{r}
tempD <- data.frame(cellNos = seq(1:ncell(hunterCovariates_sub)))
tempD$vals <- getValues(hunterCovariates_sub)
tempD <- tempD[complete.cases(tempD), ]
tempD
cellNos <- c(tempD$cellNos)
gXY <- data.frame(xyFromCell(hunterCovariates_sub, cellNos, spatial = FALSE))
gXY
```
Using the idw function from gstat we fit the formula as below. We need to specify the observed data, their spatial locations, and the spatial locations of the points we want to interpolate onto. The idp parameter allows you to specify the inverse distance weighting power. The default is 2, yet can be adjusted if you want to give more weighting to points closer to the interpolation point. As we can not evaluate the uncertainty of prediction with IDW, we can not really optimize this parameter.

```{r}
IDW.pred <- idw(hv.dat$pH60_100cm ~ 1, locations = ~x + y, data = hv.dat, newdata = gXY, idp = 2)
```
Plotting the resulting map below can be done using the following script

```{r}
IDW.raster.p <- rasterFromXYZ(as.data.frame(IDW.pred[, 1:3]))
plot(IDW.raster.p)
```
# Kriging
